{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { ToneAudioBuffers } from \"../core/context/ToneAudioBuffers\";\nimport { ftomf, intervalToFrequencyRatio } from \"../core/type/Conversions\";\nimport { FrequencyClass } from \"../core/type/Frequency\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\nimport { isArray, isNote, isNumber } from \"../core/util/TypeCheck\";\nimport { Instrument } from \"../instrument/Instrument\";\nimport { ToneBufferSource } from \"../source/buffer/ToneBufferSource\";\nimport { timeRange } from \"../core/util/Decorator\";\nimport { assert } from \"../core/util/Debug\";\n/**\n * Pass in an object which maps the note's pitch or midi value to the url,\n * then you can trigger the attack and release of that note like other instruments.\n * By automatically repitching the samples, it is possible to play pitches which\n * were not explicitly included which can save loading time.\n *\n * For sample or buffer playback where repitching is not necessary,\n * use [[Player]].\n * @example\n * const sampler = new Tone.Sampler({\n * \turls: {\n * \t\tA1: \"A1.mp3\",\n * \t\tA2: \"A2.mp3\",\n * \t},\n * \tbaseUrl: \"https://tonejs.github.io/audio/casio/\",\n * \tonload: () => {\n * \t\tsampler.triggerAttackRelease([\"C1\", \"E1\", \"G1\", \"B1\"], 0.5);\n * \t}\n * }).toDestination();\n * @category Instrument\n */\n\nexport class Sampler extends Instrument {\n  constructor() {\n    super(optionsFromArguments(Sampler.getDefaults(), arguments, [\"urls\", \"onload\", \"baseUrl\"], \"urls\"));\n    this.name = \"Sampler\";\n    /**\n     * The object of all currently playing BufferSources\n     */\n\n    this._activeSources = new Map();\n    const options = optionsFromArguments(Sampler.getDefaults(), arguments, [\"urls\", \"onload\", \"baseUrl\"], \"urls\");\n    const urlMap = {};\n    Object.keys(options.urls).forEach(note => {\n      const noteNumber = parseInt(note, 10);\n      assert(isNote(note) || isNumber(noteNumber) && isFinite(noteNumber), `url key is neither a note or midi pitch: ${note}`);\n\n      if (isNote(note)) {\n        // convert the note name to MIDI\n        const mid = new FrequencyClass(this.context, note).toMidi();\n        urlMap[mid] = options.urls[note];\n      } else if (isNumber(noteNumber) && isFinite(noteNumber)) {\n        // otherwise if it's numbers assume it's midi\n        urlMap[noteNumber] = options.urls[noteNumber];\n      }\n    });\n    this._buffers = new ToneAudioBuffers({\n      urls: urlMap,\n      onload: options.onload,\n      baseUrl: options.baseUrl,\n      onerror: options.onerror\n    });\n    this.attack = options.attack;\n    this.release = options.release;\n    this.curve = options.curve; // invoke the callback if it's already loaded\n\n    if (this._buffers.loaded) {\n      // invoke onload deferred\n      Promise.resolve().then(options.onload);\n    }\n  }\n\n  static getDefaults() {\n    return Object.assign(Instrument.getDefaults(), {\n      attack: 0,\n      baseUrl: \"\",\n      curve: \"exponential\",\n      onload: noOp,\n      onerror: noOp,\n      release: 0.1,\n      urls: {}\n    });\n  }\n  /**\n   * Returns the difference in steps between the given midi note at the closets sample.\n   */\n\n\n  _findClosest(midi) {\n    // searches within 8 octaves of the given midi note\n    const MAX_INTERVAL = 96;\n    let interval = 0;\n\n    while (interval < MAX_INTERVAL) {\n      // check above and below\n      if (this._buffers.has(midi + interval)) {\n        return -interval;\n      } else if (this._buffers.has(midi - interval)) {\n        return interval;\n      }\n\n      interval++;\n    }\n\n    throw new Error(`No available buffers for note: ${midi}`);\n  }\n  /**\n   * @param  notes\tThe note to play, or an array of notes.\n   * @param  time     When to play the note\n   * @param  velocity The velocity to play the sample back.\n   */\n\n\n  triggerAttack(notes, time) {\n    let velocity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    this.log(\"triggerAttack\", notes, time, velocity);\n\n    if (!Array.isArray(notes)) {\n      notes = [notes];\n    }\n\n    notes.forEach(note => {\n      const midiFloat = ftomf(new FrequencyClass(this.context, note).toFrequency());\n      const midi = Math.round(midiFloat);\n      const remainder = midiFloat - midi; // find the closest note pitch\n\n      const difference = this._findClosest(midi);\n\n      const closestNote = midi - difference;\n\n      const buffer = this._buffers.get(closestNote);\n\n      const playbackRate = intervalToFrequencyRatio(difference + remainder); // play that note\n\n      const source = new ToneBufferSource({\n        url: buffer,\n        context: this.context,\n        curve: this.curve,\n        fadeIn: this.attack,\n        fadeOut: this.release,\n        playbackRate\n      }).connect(this.output);\n      source.start(time, 0, buffer.duration / playbackRate, velocity); // add it to the active sources\n\n      if (!isArray(this._activeSources.get(midi))) {\n        this._activeSources.set(midi, []);\n      }\n\n      this._activeSources.get(midi).push(source); // remove it when it's done\n\n\n      source.onended = () => {\n        if (this._activeSources && this._activeSources.has(midi)) {\n          const sources = this._activeSources.get(midi);\n\n          const index = sources.indexOf(source);\n\n          if (index !== -1) {\n            sources.splice(index, 1);\n          }\n        }\n      };\n    });\n    return this;\n  }\n  /**\n   * @param  notes\tThe note to release, or an array of notes.\n   * @param  time     \tWhen to release the note.\n   */\n\n\n  triggerRelease(notes, time) {\n    this.log(\"triggerRelease\", notes, time);\n\n    if (!Array.isArray(notes)) {\n      notes = [notes];\n    }\n\n    notes.forEach(note => {\n      const midi = new FrequencyClass(this.context, note).toMidi(); // find the note\n\n      if (this._activeSources.has(midi) && this._activeSources.get(midi).length) {\n        const sources = this._activeSources.get(midi);\n\n        time = this.toSeconds(time);\n        sources.forEach(source => {\n          source.stop(time);\n        });\n\n        this._activeSources.set(midi, []);\n      }\n    });\n    return this;\n  }\n  /**\n   * Release all currently active notes.\n   * @param  time     \tWhen to release the notes.\n   */\n\n\n  releaseAll(time) {\n    const computedTime = this.toSeconds(time);\n\n    this._activeSources.forEach(sources => {\n      while (sources.length) {\n        const source = sources.shift();\n        source.stop(computedTime);\n      }\n    });\n\n    return this;\n  }\n\n  sync() {\n    if (this._syncState()) {\n      this._syncMethod(\"triggerAttack\", 1);\n\n      this._syncMethod(\"triggerRelease\", 1);\n    }\n\n    return this;\n  }\n  /**\n   * Invoke the attack phase, then after the duration, invoke the release.\n   * @param  notes\tThe note to play and release, or an array of notes.\n   * @param  duration The time the note should be held\n   * @param  time     When to start the attack\n   * @param  velocity The velocity of the attack\n   */\n\n\n  triggerAttackRelease(notes, duration, time) {\n    let velocity = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n    const computedTime = this.toSeconds(time);\n    this.triggerAttack(notes, computedTime, velocity);\n\n    if (isArray(duration)) {\n      assert(isArray(notes), \"notes must be an array when duration is array\");\n      notes.forEach((note, index) => {\n        const d = duration[Math.min(index, duration.length - 1)];\n        this.triggerRelease(note, computedTime + this.toSeconds(d));\n      });\n    } else {\n      this.triggerRelease(notes, computedTime + this.toSeconds(duration));\n    }\n\n    return this;\n  }\n  /**\n   * Add a note to the sampler.\n   * @param  note      The buffer's pitch.\n   * @param  url  Either the url of the buffer, or a buffer which will be added with the given name.\n   * @param  callback  The callback to invoke when the url is loaded.\n   */\n\n\n  add(note, url, callback) {\n    assert(isNote(note) || isFinite(note), `note must be a pitch or midi: ${note}`);\n\n    if (isNote(note)) {\n      // convert the note name to MIDI\n      const mid = new FrequencyClass(this.context, note).toMidi();\n\n      this._buffers.add(mid, url, callback);\n    } else {\n      // otherwise if it's numbers assume it's midi\n      this._buffers.add(note, url, callback);\n    }\n\n    return this;\n  }\n  /**\n   * If the buffers are loaded or not\n   */\n\n\n  get loaded() {\n    return this._buffers.loaded;\n  }\n  /**\n   * Clean up\n   */\n\n\n  dispose() {\n    super.dispose();\n\n    this._buffers.dispose();\n\n    this._activeSources.forEach(sources => {\n      sources.forEach(source => source.dispose());\n    });\n\n    this._activeSources.clear();\n\n    return this;\n  }\n\n}\n\n__decorate([timeRange(0)], Sampler.prototype, \"attack\", void 0);\n\n__decorate([timeRange(0)], Sampler.prototype, \"release\", void 0);","map":null,"metadata":{},"sourceType":"module"}