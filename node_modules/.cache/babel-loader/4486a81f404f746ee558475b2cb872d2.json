{"ast":null,"code":"import { StereoEffect } from \"./StereoEffect\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Scale } from \"../signal/Scale\";\nimport { Signal } from \"../signal/Signal\";\nimport { FeedbackCombFilter } from \"../component/filter/FeedbackCombFilter\";\nimport { readOnly } from \"../core/util/Interface\";\n/**\n * an array of the comb filter delay time values\n */\n\nconst combFilterDelayTimes = [1687 / 25000, 1601 / 25000, 2053 / 25000, 2251 / 25000];\n/**\n * the resonances of each of the comb filters\n */\n\nconst combFilterResonances = [0.773, 0.802, 0.753, 0.733];\n/**\n * the allpass filter frequencies\n */\n\nconst allpassFilterFreqs = [347, 113, 37];\n/**\n * JCReverb is a simple [Schroeder Reverberator](https://ccrma.stanford.edu/~jos/pasp/Schroeder_Reverberators.html)\n * tuned by John Chowning in 1970.\n * It is made up of three allpass filters and four [[FeedbackCombFilter]].\n * JCReverb is now implemented with an AudioWorkletNode which may result on performance degradation on some platforms. Consider using [[Reverb]].\n * @example\n * const reverb = new Tone.JCReverb(0.4).toDestination();\n * const delay = new Tone.FeedbackDelay(0.5);\n * // connecting the synth to reverb through delay\n * const synth = new Tone.DuoSynth().chain(delay, reverb);\n * synth.triggerAttackRelease(\"A4\", \"8n\");\n *\n * @category Effect\n */\n\nexport class JCReverb extends StereoEffect {\n  constructor() {\n    super(optionsFromArguments(JCReverb.getDefaults(), arguments, [\"roomSize\"]));\n    this.name = \"JCReverb\";\n    /**\n     * a series of allpass filters\n     */\n\n    this._allpassFilters = [];\n    /**\n     * parallel feedback comb filters\n     */\n\n    this._feedbackCombFilters = [];\n    const options = optionsFromArguments(JCReverb.getDefaults(), arguments, [\"roomSize\"]);\n    this.roomSize = new Signal({\n      context: this.context,\n      value: options.roomSize,\n      units: \"normalRange\"\n    });\n    this._scaleRoomSize = new Scale({\n      context: this.context,\n      min: -0.733,\n      max: 0.197\n    }); // make the allpass filters\n\n    this._allpassFilters = allpassFilterFreqs.map(freq => {\n      const allpass = this.context.createBiquadFilter();\n      allpass.type = \"allpass\";\n      allpass.frequency.value = freq;\n      return allpass;\n    }); // and the comb filters\n\n    this._feedbackCombFilters = combFilterDelayTimes.map((delayTime, index) => {\n      const fbcf = new FeedbackCombFilter({\n        context: this.context,\n        delayTime\n      });\n\n      this._scaleRoomSize.connect(fbcf.resonance);\n\n      fbcf.resonance.value = combFilterResonances[index];\n\n      if (index < combFilterDelayTimes.length / 2) {\n        this.connectEffectLeft(...this._allpassFilters, fbcf);\n      } else {\n        this.connectEffectRight(...this._allpassFilters, fbcf);\n      }\n\n      return fbcf;\n    }); // chain the allpass filters together\n\n    this.roomSize.connect(this._scaleRoomSize);\n    readOnly(this, [\"roomSize\"]);\n  }\n\n  static getDefaults() {\n    return Object.assign(StereoEffect.getDefaults(), {\n      roomSize: 0.5\n    });\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._allpassFilters.forEach(apf => apf.disconnect());\n\n    this._feedbackCombFilters.forEach(fbcf => fbcf.dispose());\n\n    this.roomSize.dispose();\n\n    this._scaleRoomSize.dispose();\n\n    return this;\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}