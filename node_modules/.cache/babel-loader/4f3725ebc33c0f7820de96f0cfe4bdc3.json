{"ast":null,"code":"import { ToneEvent } from \"./ToneEvent\";\nimport { ToneWithContext } from \"../core/context/ToneWithContext\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\n/**\n * Loop creates a looped callback at the\n * specified interval. The callback can be\n * started, stopped and scheduled along\n * the Transport's timeline.\n * @example\n * const loop = new Tone.Loop((time) => {\n * \t// triggered every eighth note.\n * \tconsole.log(time);\n * }, \"8n\").start(0);\n * Tone.Transport.start();\n * @category Event\n */\n\nexport class Loop extends ToneWithContext {\n  constructor() {\n    super(optionsFromArguments(Loop.getDefaults(), arguments, [\"callback\", \"interval\"]));\n    this.name = \"Loop\";\n    const options = optionsFromArguments(Loop.getDefaults(), arguments, [\"callback\", \"interval\"]);\n    this._event = new ToneEvent({\n      context: this.context,\n      callback: this._tick.bind(this),\n      loop: true,\n      loopEnd: options.interval,\n      playbackRate: options.playbackRate,\n      probability: options.probability\n    });\n    this.callback = options.callback; // set the iterations\n\n    this.iterations = options.iterations;\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneWithContext.getDefaults(), {\n      interval: \"4n\",\n      callback: noOp,\n      playbackRate: 1,\n      iterations: Infinity,\n      probability: 1,\n      mute: false,\n      humanize: false\n    });\n  }\n  /**\n   * Start the loop at the specified time along the Transport's timeline.\n   * @param  time  When to start the Loop.\n   */\n\n\n  start(time) {\n    this._event.start(time);\n\n    return this;\n  }\n  /**\n   * Stop the loop at the given time.\n   * @param  time  When to stop the Loop.\n   */\n\n\n  stop(time) {\n    this._event.stop(time);\n\n    return this;\n  }\n  /**\n   * Cancel all scheduled events greater than or equal to the given time\n   * @param  time  The time after which events will be cancel.\n   */\n\n\n  cancel(time) {\n    this._event.cancel(time);\n\n    return this;\n  }\n  /**\n   * Internal function called when the notes should be called\n   * @param time  The time the event occurs\n   */\n\n\n  _tick(time) {\n    this.callback(time);\n  }\n  /**\n   * The state of the Loop, either started or stopped.\n   */\n\n\n  get state() {\n    return this._event.state;\n  }\n  /**\n   * The progress of the loop as a value between 0-1. 0, when the loop is stopped or done iterating.\n   */\n\n\n  get progress() {\n    return this._event.progress;\n  }\n  /**\n   * The time between successive callbacks.\n   * @example\n   * const loop = new Tone.Loop();\n   * loop.interval = \"8n\"; // loop every 8n\n   */\n\n\n  get interval() {\n    return this._event.loopEnd;\n  }\n\n  set interval(interval) {\n    this._event.loopEnd = interval;\n  }\n  /**\n   * The playback rate of the loop. The normal playback rate is 1 (no change).\n   * A `playbackRate` of 2 would be twice as fast.\n   */\n\n\n  get playbackRate() {\n    return this._event.playbackRate;\n  }\n\n  set playbackRate(rate) {\n    this._event.playbackRate = rate;\n  }\n  /**\n   * Random variation +/-0.01s to the scheduled time.\n   * Or give it a time value which it will randomize by.\n   */\n\n\n  get humanize() {\n    return this._event.humanize;\n  }\n\n  set humanize(variation) {\n    this._event.humanize = variation;\n  }\n  /**\n   * The probably of the callback being invoked.\n   */\n\n\n  get probability() {\n    return this._event.probability;\n  }\n\n  set probability(prob) {\n    this._event.probability = prob;\n  }\n  /**\n   * Muting the Loop means that no callbacks are invoked.\n   */\n\n\n  get mute() {\n    return this._event.mute;\n  }\n\n  set mute(mute) {\n    this._event.mute = mute;\n  }\n  /**\n   * The number of iterations of the loop. The default value is `Infinity` (loop forever).\n   */\n\n\n  get iterations() {\n    if (this._event.loop === true) {\n      return Infinity;\n    } else {\n      return this._event.loop;\n    }\n  }\n\n  set iterations(iters) {\n    if (iters === Infinity) {\n      this._event.loop = true;\n    } else {\n      this._event.loop = iters;\n    }\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._event.dispose();\n\n    return this;\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}