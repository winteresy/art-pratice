{"ast":null,"code":"import { computeBufferSize } from '../helpers/compute-buffer-size';\nimport { filterBuffer } from '../helpers/filter-buffer';\nimport { interceptConnections } from '../helpers/intercept-connections';\n\nfunction divide(a, b) {\n  const denominator = b[0] * b[0] + b[1] * b[1];\n  return [(a[0] * b[0] + a[1] * b[1]) / denominator, (a[1] * b[0] - a[0] * b[1]) / denominator];\n}\n\nfunction multiply(a, b) {\n  return [a[0] * b[0] - a[1] * b[1], a[0] * b[1] + a[1] * b[0]];\n}\n\nfunction evaluatePolynomial(coefficient, z) {\n  let result = [0, 0];\n\n  for (let i = coefficient.length - 1; i >= 0; i -= 1) {\n    result = multiply(result, z);\n    result[0] += coefficient[i];\n  }\n\n  return result;\n}\n\nexport const createNativeIIRFilterNodeFakerFactory = (createInvalidAccessError, createInvalidStateError, createNativeScriptProcessorNode, createNotSupportedError) => {\n  return (nativeContext, baseLatency, _ref) => {\n    let channelCount = _ref.channelCount,\n        channelCountMode = _ref.channelCountMode,\n        channelInterpretation = _ref.channelInterpretation,\n        feedback = _ref.feedback,\n        feedforward = _ref.feedforward;\n    const bufferSize = computeBufferSize(baseLatency, nativeContext.sampleRate);\n    const convertedFeedback = feedback instanceof Float64Array ? feedback : new Float64Array(feedback);\n    const convertedFeedforward = feedforward instanceof Float64Array ? feedforward : new Float64Array(feedforward);\n    const feedbackLength = convertedFeedback.length;\n    const feedforwardLength = convertedFeedforward.length;\n    const minLength = Math.min(feedbackLength, feedforwardLength);\n\n    if (feedbackLength === 0 || feedbackLength > 20) {\n      throw createNotSupportedError();\n    }\n\n    if (convertedFeedback[0] === 0) {\n      throw createInvalidStateError();\n    }\n\n    if (feedforwardLength === 0 || feedforwardLength > 20) {\n      throw createNotSupportedError();\n    }\n\n    if (convertedFeedforward[0] === 0) {\n      throw createInvalidStateError();\n    }\n\n    if (convertedFeedback[0] !== 1) {\n      for (let i = 0; i < feedforwardLength; i += 1) {\n        convertedFeedforward[i] /= convertedFeedback[0];\n      }\n\n      for (let i = 1; i < feedbackLength; i += 1) {\n        convertedFeedback[i] /= convertedFeedback[0];\n      }\n    }\n\n    const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, bufferSize, channelCount, channelCount);\n    scriptProcessorNode.channelCount = channelCount;\n    scriptProcessorNode.channelCountMode = channelCountMode;\n    scriptProcessorNode.channelInterpretation = channelInterpretation;\n    const bufferLength = 32;\n    const bufferIndexes = [];\n    const xBuffers = [];\n    const yBuffers = [];\n\n    for (let i = 0; i < channelCount; i += 1) {\n      bufferIndexes.push(0);\n      const xBuffer = new Float32Array(bufferLength);\n      const yBuffer = new Float32Array(bufferLength);\n      xBuffer.fill(0);\n      yBuffer.fill(0);\n      xBuffers.push(xBuffer);\n      yBuffers.push(yBuffer);\n    } // tslint:disable-next-line:deprecation\n\n\n    scriptProcessorNode.onaudioprocess = event => {\n      const inputBuffer = event.inputBuffer;\n      const outputBuffer = event.outputBuffer;\n      const numberOfChannels = inputBuffer.numberOfChannels;\n\n      for (let i = 0; i < numberOfChannels; i += 1) {\n        const input = inputBuffer.getChannelData(i);\n        const output = outputBuffer.getChannelData(i);\n        bufferIndexes[i] = filterBuffer(convertedFeedback, feedbackLength, convertedFeedforward, feedforwardLength, minLength, xBuffers[i], yBuffers[i], bufferIndexes[i], bufferLength, input, output);\n      }\n    };\n\n    const nyquist = nativeContext.sampleRate / 2;\n    const nativeIIRFilterNodeFaker = {\n      get bufferSize() {\n        return bufferSize;\n      },\n\n      get channelCount() {\n        return scriptProcessorNode.channelCount;\n      },\n\n      set channelCount(value) {\n        scriptProcessorNode.channelCount = value;\n      },\n\n      get channelCountMode() {\n        return scriptProcessorNode.channelCountMode;\n      },\n\n      set channelCountMode(value) {\n        scriptProcessorNode.channelCountMode = value;\n      },\n\n      get channelInterpretation() {\n        return scriptProcessorNode.channelInterpretation;\n      },\n\n      set channelInterpretation(value) {\n        scriptProcessorNode.channelInterpretation = value;\n      },\n\n      get context() {\n        return scriptProcessorNode.context;\n      },\n\n      get inputs() {\n        return [scriptProcessorNode];\n      },\n\n      get numberOfInputs() {\n        return scriptProcessorNode.numberOfInputs;\n      },\n\n      get numberOfOutputs() {\n        return scriptProcessorNode.numberOfOutputs;\n      },\n\n      addEventListener() {\n        // @todo Dissallow adding an audioprocess listener.\n        return scriptProcessorNode.addEventListener(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);\n      },\n\n      dispatchEvent() {\n        return scriptProcessorNode.dispatchEvent(arguments.length <= 0 ? undefined : arguments[0]);\n      },\n\n      getFrequencyResponse(frequencyHz, magResponse, phaseResponse) {\n        if (frequencyHz.length !== magResponse.length || magResponse.length !== phaseResponse.length) {\n          throw createInvalidAccessError();\n        }\n\n        const length = frequencyHz.length;\n\n        for (let i = 0; i < length; i += 1) {\n          const omega = -Math.PI * (frequencyHz[i] / nyquist);\n          const z = [Math.cos(omega), Math.sin(omega)];\n          const numerator = evaluatePolynomial(convertedFeedforward, z);\n          const denominator = evaluatePolynomial(convertedFeedback, z);\n          const response = divide(numerator, denominator);\n          magResponse[i] = Math.sqrt(response[0] * response[0] + response[1] * response[1]);\n          phaseResponse[i] = Math.atan2(response[1], response[0]);\n        }\n      },\n\n      removeEventListener() {\n        return scriptProcessorNode.removeEventListener(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);\n      }\n\n    };\n    return interceptConnections(nativeIIRFilterNodeFaker, scriptProcessorNode);\n  };\n};","map":null,"metadata":{},"sourceType":"module"}