{"ast":null,"code":"import { AutomationEventList } from 'automation-events';\nexport const createAudioParamFactory = (addAudioParamConnections, audioParamAudioNodeStore, audioParamStore, createAudioParamRenderer, createCancelAndHoldAutomationEvent, createCancelScheduledValuesAutomationEvent, createExponentialRampToValueAutomationEvent, createLinearRampToValueAutomationEvent, createSetTargetAutomationEvent, createSetValueAutomationEvent, createSetValueCurveAutomationEvent, nativeAudioContextConstructor, setValueAtTimeUntilPossible) => {\n  return function (audioNode, isAudioParamOfOfflineAudioContext, nativeAudioParam) {\n    let maxValue = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    let minValue = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    const automationEventList = new AutomationEventList(nativeAudioParam.defaultValue);\n    const audioParamRenderer = isAudioParamOfOfflineAudioContext ? createAudioParamRenderer(automationEventList) : null;\n    const audioParam = {\n      get defaultValue() {\n        return nativeAudioParam.defaultValue;\n      },\n\n      get maxValue() {\n        return maxValue === null ? nativeAudioParam.maxValue : maxValue;\n      },\n\n      get minValue() {\n        return minValue === null ? nativeAudioParam.minValue : minValue;\n      },\n\n      get value() {\n        return nativeAudioParam.value;\n      },\n\n      set value(value) {\n        nativeAudioParam.value = value; // Bug #98: Firefox & Safari do not yet treat the value setter like a call to setValueAtTime().\n\n        audioParam.setValueAtTime(value, audioNode.context.currentTime);\n      },\n\n      cancelAndHoldAtTime(cancelTime) {\n        // Bug #28: Firefox & Safari do not yet implement cancelAndHoldAtTime().\n        if (typeof nativeAudioParam.cancelAndHoldAtTime === 'function') {\n          if (audioParamRenderer === null) {\n            automationEventList.flush(audioNode.context.currentTime);\n          }\n\n          automationEventList.add(createCancelAndHoldAutomationEvent(cancelTime));\n          nativeAudioParam.cancelAndHoldAtTime(cancelTime);\n        } else {\n          const previousLastEvent = Array.from(automationEventList).pop();\n\n          if (audioParamRenderer === null) {\n            automationEventList.flush(audioNode.context.currentTime);\n          }\n\n          automationEventList.add(createCancelAndHoldAutomationEvent(cancelTime));\n          const currentLastEvent = Array.from(automationEventList).pop();\n          nativeAudioParam.cancelScheduledValues(cancelTime);\n\n          if (previousLastEvent !== currentLastEvent && currentLastEvent !== undefined) {\n            if (currentLastEvent.type === 'exponentialRampToValue') {\n              nativeAudioParam.exponentialRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);\n            } else if (currentLastEvent.type === 'linearRampToValue') {\n              nativeAudioParam.linearRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);\n            } else if (currentLastEvent.type === 'setValue') {\n              nativeAudioParam.setValueAtTime(currentLastEvent.value, currentLastEvent.startTime);\n            } else if (currentLastEvent.type === 'setValueCurve') {\n              nativeAudioParam.setValueCurveAtTime(currentLastEvent.values, currentLastEvent.startTime, currentLastEvent.duration);\n            }\n          }\n        }\n\n        return audioParam;\n      },\n\n      cancelScheduledValues(cancelTime) {\n        if (audioParamRenderer === null) {\n          automationEventList.flush(audioNode.context.currentTime);\n        }\n\n        automationEventList.add(createCancelScheduledValuesAutomationEvent(cancelTime));\n        nativeAudioParam.cancelScheduledValues(cancelTime);\n        return audioParam;\n      },\n\n      exponentialRampToValueAtTime(value, endTime) {\n        // Bug #45: Safari does not throw an error yet.\n        if (value === 0) {\n          throw new RangeError();\n        } // Bug #187: Safari does not throw an error yet.\n\n\n        if (!Number.isFinite(endTime) || endTime < 0) {\n          throw new RangeError();\n        }\n\n        if (audioParamRenderer === null) {\n          automationEventList.flush(audioNode.context.currentTime);\n        }\n\n        automationEventList.add(createExponentialRampToValueAutomationEvent(value, endTime));\n        nativeAudioParam.exponentialRampToValueAtTime(value, endTime);\n        return audioParam;\n      },\n\n      linearRampToValueAtTime(value, endTime) {\n        if (audioParamRenderer === null) {\n          automationEventList.flush(audioNode.context.currentTime);\n        }\n\n        automationEventList.add(createLinearRampToValueAutomationEvent(value, endTime));\n        nativeAudioParam.linearRampToValueAtTime(value, endTime);\n        return audioParam;\n      },\n\n      setTargetAtTime(target, startTime, timeConstant) {\n        if (audioParamRenderer === null) {\n          automationEventList.flush(audioNode.context.currentTime);\n        }\n\n        automationEventList.add(createSetTargetAutomationEvent(target, startTime, timeConstant));\n        nativeAudioParam.setTargetAtTime(target, startTime, timeConstant);\n        return audioParam;\n      },\n\n      setValueAtTime(value, startTime) {\n        if (audioParamRenderer === null) {\n          automationEventList.flush(audioNode.context.currentTime);\n        }\n\n        automationEventList.add(createSetValueAutomationEvent(value, startTime));\n        nativeAudioParam.setValueAtTime(value, startTime);\n        return audioParam;\n      },\n\n      setValueCurveAtTime(values, startTime, duration) {\n        // Bug 183: Safari only accepts a Float32Array.\n        const convertedValues = values instanceof Float32Array ? values : new Float32Array(values);\n        /*\n         * Bug #152: Safari does not correctly interpolate the values of the curve.\n         * @todo Unfortunately there is no way to test for this behavior in a synchronous fashion which is why testing for the\n         * existence of the webkitAudioContext is used as a workaround here.\n         */\n\n        if (nativeAudioContextConstructor !== null && nativeAudioContextConstructor.name === 'webkitAudioContext') {\n          const endTime = startTime + duration;\n          const sampleRate = audioNode.context.sampleRate;\n          const firstSample = Math.ceil(startTime * sampleRate);\n          const lastSample = Math.floor(endTime * sampleRate);\n          const numberOfInterpolatedValues = lastSample - firstSample;\n          const interpolatedValues = new Float32Array(numberOfInterpolatedValues);\n\n          for (let i = 0; i < numberOfInterpolatedValues; i += 1) {\n            const theoreticIndex = (convertedValues.length - 1) / duration * ((firstSample + i) / sampleRate - startTime);\n            const lowerIndex = Math.floor(theoreticIndex);\n            const upperIndex = Math.ceil(theoreticIndex);\n            interpolatedValues[i] = lowerIndex === upperIndex ? convertedValues[lowerIndex] : (1 - (theoreticIndex - lowerIndex)) * convertedValues[lowerIndex] + (1 - (upperIndex - theoreticIndex)) * convertedValues[upperIndex];\n          }\n\n          if (audioParamRenderer === null) {\n            automationEventList.flush(audioNode.context.currentTime);\n          }\n\n          automationEventList.add(createSetValueCurveAutomationEvent(interpolatedValues, startTime, duration));\n          nativeAudioParam.setValueCurveAtTime(interpolatedValues, startTime, duration);\n          const timeOfLastSample = lastSample / sampleRate;\n\n          if (timeOfLastSample < endTime) {\n            setValueAtTimeUntilPossible(audioParam, interpolatedValues[interpolatedValues.length - 1], timeOfLastSample);\n          }\n\n          setValueAtTimeUntilPossible(audioParam, convertedValues[convertedValues.length - 1], endTime);\n        } else {\n          if (audioParamRenderer === null) {\n            automationEventList.flush(audioNode.context.currentTime);\n          }\n\n          automationEventList.add(createSetValueCurveAutomationEvent(convertedValues, startTime, duration));\n          nativeAudioParam.setValueCurveAtTime(convertedValues, startTime, duration);\n        }\n\n        return audioParam;\n      }\n\n    };\n    audioParamStore.set(audioParam, nativeAudioParam);\n    audioParamAudioNodeStore.set(audioParam, audioNode);\n    addAudioParamConnections(audioParam, audioParamRenderer);\n    return audioParam;\n  };\n};","map":null,"metadata":{},"sourceType":"module"}