{"ast":null,"code":"import { TicksClass } from \"../core/type/Ticks\";\nimport { omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { isArray, isString } from \"../core/util/TypeCheck\";\nimport { Part } from \"./Part\";\nimport { ToneEvent } from \"./ToneEvent\";\n/**\n * A sequence is an alternate notation of a part. Instead\n * of passing in an array of [time, event] pairs, pass\n * in an array of events which will be spaced at the\n * given subdivision. Sub-arrays will subdivide that beat\n * by the number of items are in the array.\n * Sequence notation inspiration from [Tidal](http://yaxu.org/tidal/)\n * @example\n * const synth = new Tone.Synth().toDestination();\n * const seq = new Tone.Sequence((time, note) => {\n * \tsynth.triggerAttackRelease(note, 0.1, time);\n * \t// subdivisions are given as subarrays\n * }, [\"C4\", [\"E4\", \"D4\", \"E4\"], \"G4\", [\"A4\", \"G4\"]]).start(0);\n * Tone.Transport.start();\n * @category Event\n */\n\nexport class Sequence extends ToneEvent {\n  constructor() {\n    super(optionsFromArguments(Sequence.getDefaults(), arguments, [\"callback\", \"events\", \"subdivision\"]));\n    this.name = \"Sequence\";\n    /**\n     * The object responsible for scheduling all of the events\n     */\n\n    this._part = new Part({\n      callback: this._seqCallback.bind(this),\n      context: this.context\n    });\n    /**\n     * private reference to all of the sequence proxies\n     */\n\n    this._events = [];\n    /**\n     * The proxied array\n     */\n\n    this._eventsArray = [];\n    const options = optionsFromArguments(Sequence.getDefaults(), arguments, [\"callback\", \"events\", \"subdivision\"]);\n    this._subdivision = this.toTicks(options.subdivision);\n    this.events = options.events; // set all of the values\n\n    this.loop = options.loop;\n    this.loopStart = options.loopStart;\n    this.loopEnd = options.loopEnd;\n    this.playbackRate = options.playbackRate;\n    this.probability = options.probability;\n    this.humanize = options.humanize;\n    this.mute = options.mute;\n    this.playbackRate = options.playbackRate;\n  }\n\n  static getDefaults() {\n    return Object.assign(omitFromObject(ToneEvent.getDefaults(), [\"value\"]), {\n      events: [],\n      loop: true,\n      loopEnd: 0,\n      loopStart: 0,\n      subdivision: \"8n\"\n    });\n  }\n  /**\n   * The internal callback for when an event is invoked\n   */\n\n\n  _seqCallback(time, value) {\n    if (value !== null) {\n      this.callback(time, value);\n    }\n  }\n  /**\n   * The sequence\n   */\n\n\n  get events() {\n    return this._events;\n  }\n\n  set events(s) {\n    this.clear();\n    this._eventsArray = s;\n    this._events = this._createSequence(this._eventsArray);\n\n    this._eventsUpdated();\n  }\n  /**\n   * Start the part at the given time.\n   * @param  time    When to start the part.\n   * @param  offset  The offset index to start at\n   */\n\n\n  start(time, offset) {\n    this._part.start(time, offset ? this._indexTime(offset) : offset);\n\n    return this;\n  }\n  /**\n   * Stop the part at the given time.\n   * @param  time  When to stop the part.\n   */\n\n\n  stop(time) {\n    this._part.stop(time);\n\n    return this;\n  }\n  /**\n   * The subdivision of the sequence. This can only be\n   * set in the constructor. The subdivision is the\n   * interval between successive steps.\n   */\n\n\n  get subdivision() {\n    return new TicksClass(this.context, this._subdivision).toSeconds();\n  }\n  /**\n   * Create a sequence proxy which can be monitored to create subsequences\n   */\n\n\n  _createSequence(array) {\n    return new Proxy(array, {\n      get: (target, property) => {\n        // property is index in this case\n        return target[property];\n      },\n      set: (target, property, value) => {\n        if (isString(property) && isFinite(parseInt(property, 10))) {\n          if (isArray(value)) {\n            target[property] = this._createSequence(value);\n          } else {\n            target[property] = value;\n          }\n        } else {\n          target[property] = value;\n        }\n\n        this._eventsUpdated(); // return true to accept the changes\n\n\n        return true;\n      }\n    });\n  }\n  /**\n   * When the sequence has changed, all of the events need to be recreated\n   */\n\n\n  _eventsUpdated() {\n    this._part.clear();\n\n    this._rescheduleSequence(this._eventsArray, this._subdivision, this.startOffset); // update the loopEnd\n\n\n    this.loopEnd = this.loopEnd;\n  }\n  /**\n   * reschedule all of the events that need to be rescheduled\n   */\n\n\n  _rescheduleSequence(sequence, subdivision, startOffset) {\n    sequence.forEach((value, index) => {\n      const eventOffset = index * subdivision + startOffset;\n\n      if (isArray(value)) {\n        this._rescheduleSequence(value, subdivision / value.length, eventOffset);\n      } else {\n        const startTime = new TicksClass(this.context, eventOffset, \"i\").toSeconds();\n\n        this._part.add(startTime, value);\n      }\n    });\n  }\n  /**\n   * Get the time of the index given the Sequence's subdivision\n   * @param  index\n   * @return The time of that index\n   */\n\n\n  _indexTime(index) {\n    return new TicksClass(this.context, index * this._subdivision + this.startOffset).toSeconds();\n  }\n  /**\n   * Clear all of the events\n   */\n\n\n  clear() {\n    this._part.clear();\n\n    return this;\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._part.dispose();\n\n    return this;\n  } //-------------------------------------\n  // PROXY CALLS\n  //-------------------------------------\n\n\n  get loop() {\n    return this._part.loop;\n  }\n\n  set loop(l) {\n    this._part.loop = l;\n  }\n  /**\n   * The index at which the sequence should start looping\n   */\n\n\n  get loopStart() {\n    return this._loopStart;\n  }\n\n  set loopStart(index) {\n    this._loopStart = index;\n    this._part.loopStart = this._indexTime(index);\n  }\n  /**\n   * The index at which the sequence should end looping\n   */\n\n\n  get loopEnd() {\n    return this._loopEnd;\n  }\n\n  set loopEnd(index) {\n    this._loopEnd = index;\n\n    if (index === 0) {\n      this._part.loopEnd = this._indexTime(this._eventsArray.length);\n    } else {\n      this._part.loopEnd = this._indexTime(index);\n    }\n  }\n\n  get startOffset() {\n    return this._part.startOffset;\n  }\n\n  set startOffset(start) {\n    this._part.startOffset = start;\n  }\n\n  get playbackRate() {\n    return this._part.playbackRate;\n  }\n\n  set playbackRate(rate) {\n    this._part.playbackRate = rate;\n  }\n\n  get probability() {\n    return this._part.probability;\n  }\n\n  set probability(prob) {\n    this._part.probability = prob;\n  }\n\n  get progress() {\n    return this._part.progress;\n  }\n\n  get humanize() {\n    return this._part.humanize;\n  }\n\n  set humanize(variation) {\n    this._part.humanize = variation;\n  }\n  /**\n   * The number of scheduled events\n   */\n\n\n  get length() {\n    return this._part.length;\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}