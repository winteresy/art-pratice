{"ast":null,"code":"import { getContext } from \"../Global\";\nimport { ftom } from \"./Conversions\";\nimport { TimeBaseClass } from \"./TimeBase\";\n/**\n * TimeClass is a primitive type for encoding and decoding Time values.\n * TimeClass can be passed into the parameter of any method which takes time as an argument.\n * @param  val    The time value.\n * @param  units  The units of the value.\n * @example\n * const time = Tone.Time(\"4n\"); // a quarter note\n * @category Unit\n */\n\nexport class TimeClass extends TimeBaseClass {\n  constructor() {\n    super(...arguments);\n    this.name = \"TimeClass\";\n  }\n\n  _getExpressions() {\n    return Object.assign(super._getExpressions(), {\n      now: {\n        method: capture => {\n          return this._now() + new this.constructor(this.context, capture).valueOf();\n        },\n        regexp: /^\\+(.+)/\n      },\n      quantize: {\n        method: capture => {\n          const quantTo = new TimeClass(this.context, capture).valueOf();\n          return this._secondsToUnits(this.context.transport.nextSubdivision(quantTo));\n        },\n        regexp: /^@(.+)/\n      }\n    });\n  }\n  /**\n   * Quantize the time by the given subdivision. Optionally add a\n   * percentage which will move the time value towards the ideal\n   * quantized value by that percentage.\n   * @param  subdiv    The subdivision to quantize to\n   * @param  percent  Move the time value towards the quantized value by a percentage.\n   * @example\n   * Tone.Time(21).quantize(2); // returns 22\n   * Tone.Time(0.6).quantize(\"4n\", 0.5); // returns 0.55\n   */\n\n\n  quantize(subdiv) {\n    let percent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    const subdivision = new this.constructor(this.context, subdiv).valueOf();\n    const value = this.valueOf();\n    const multiple = Math.round(value / subdivision);\n    const ideal = multiple * subdivision;\n    const diff = ideal - value;\n    return value + diff * percent;\n  } //-------------------------------------\n  // CONVERSIONS\n  //-------------------------------------\n\n  /**\n   * Convert a Time to Notation. The notation values are will be the\n   * closest representation between 1m to 128th note.\n   * @return {Notation}\n   * @example\n   * // if the Transport is at 120bpm:\n   * Tone.Time(2).toNotation(); // returns \"1m\"\n   */\n\n\n  toNotation() {\n    const time = this.toSeconds();\n    const testNotations = [\"1m\"];\n\n    for (let power = 1; power < 9; power++) {\n      const subdiv = Math.pow(2, power);\n      testNotations.push(subdiv + \"n.\");\n      testNotations.push(subdiv + \"n\");\n      testNotations.push(subdiv + \"t\");\n    }\n\n    testNotations.push(\"0\"); // find the closets notation representation\n\n    let closest = testNotations[0];\n    let closestSeconds = new TimeClass(this.context, testNotations[0]).toSeconds();\n    testNotations.forEach(notation => {\n      const notationSeconds = new TimeClass(this.context, notation).toSeconds();\n\n      if (Math.abs(notationSeconds - time) < Math.abs(closestSeconds - time)) {\n        closest = notation;\n        closestSeconds = notationSeconds;\n      }\n    });\n    return closest;\n  }\n  /**\n   * Return the time encoded as Bars:Beats:Sixteenths.\n   */\n\n\n  toBarsBeatsSixteenths() {\n    const quarterTime = this._beatsToUnits(1);\n\n    let quarters = this.valueOf() / quarterTime;\n    quarters = parseFloat(quarters.toFixed(4));\n    const measures = Math.floor(quarters / this._getTimeSignature());\n    let sixteenths = quarters % 1 * 4;\n    quarters = Math.floor(quarters) % this._getTimeSignature();\n    const sixteenthString = sixteenths.toString();\n\n    if (sixteenthString.length > 3) {\n      // the additional parseFloat removes insignificant trailing zeroes\n      sixteenths = parseFloat(parseFloat(sixteenthString).toFixed(3));\n    }\n\n    const progress = [measures, quarters, sixteenths];\n    return progress.join(\":\");\n  }\n  /**\n   * Return the time in ticks.\n   */\n\n\n  toTicks() {\n    const quarterTime = this._beatsToUnits(1);\n\n    const quarters = this.valueOf() / quarterTime;\n    return Math.round(quarters * this._getPPQ());\n  }\n  /**\n   * Return the time in seconds.\n   */\n\n\n  toSeconds() {\n    return this.valueOf();\n  }\n  /**\n   * Return the value as a midi note.\n   */\n\n\n  toMidi() {\n    return ftom(this.toFrequency());\n  }\n\n  _now() {\n    return this.context.now();\n  }\n\n}\n/**\n * Create a TimeClass from a time string or number. The time is computed against the\n * global Tone.Context. To use a specific context, use [[TimeClass]]\n * @param value A value which represents time\n * @param units The value's units if they can't be inferred by the value.\n * @category Unit\n * @example\n * const time = Tone.Time(\"4n\").toSeconds();\n * console.log(time);\n * @example\n * const note = Tone.Time(1).toNotation();\n * console.log(note);\n * @example\n * const freq = Tone.Time(0.5).toFrequency();\n * console.log(freq);\n */\n\nexport function Time(value, units) {\n  return new TimeClass(getContext(), value, units);\n}","map":null,"metadata":{},"sourceType":"module"}