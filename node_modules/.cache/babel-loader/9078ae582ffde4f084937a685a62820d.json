{"ast":null,"code":"import { Signal } from \"../signal/Signal\";\nimport { Multiply } from \"../signal/Multiply\";\nimport { Gain } from \"../core/context/Gain\";\nimport { Envelope } from \"../component/envelope/Envelope\";\nimport { ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { Monophonic } from \"./Monophonic\";\nimport { OmniOscillator } from \"../source/oscillator/OmniOscillator\";\nimport { Source } from \"../source/Source\";\nimport { Synth } from \"./Synth\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\n/**\n * Base class for both AM and FM synths\n */\n\nexport class ModulationSynth extends Monophonic {\n  constructor() {\n    super(optionsFromArguments(ModulationSynth.getDefaults(), arguments));\n    this.name = \"ModulationSynth\";\n    const options = optionsFromArguments(ModulationSynth.getDefaults(), arguments);\n    this._carrier = new Synth({\n      context: this.context,\n      oscillator: options.oscillator,\n      envelope: options.envelope,\n      onsilence: () => this.onsilence(this),\n      volume: -10\n    });\n    this._modulator = new Synth({\n      context: this.context,\n      oscillator: options.modulation,\n      envelope: options.modulationEnvelope,\n      volume: -10\n    });\n    this.oscillator = this._carrier.oscillator;\n    this.envelope = this._carrier.envelope;\n    this.modulation = this._modulator.oscillator;\n    this.modulationEnvelope = this._modulator.envelope;\n    this.frequency = new Signal({\n      context: this.context,\n      units: \"frequency\"\n    });\n    this.detune = new Signal({\n      context: this.context,\n      value: options.detune,\n      units: \"cents\"\n    });\n    this.harmonicity = new Multiply({\n      context: this.context,\n      value: options.harmonicity,\n      minValue: 0\n    });\n    this._modulationNode = new Gain({\n      context: this.context,\n      gain: 0\n    });\n    readOnly(this, [\"frequency\", \"harmonicity\", \"oscillator\", \"envelope\", \"modulation\", \"modulationEnvelope\", \"detune\"]);\n  }\n\n  static getDefaults() {\n    return Object.assign(Monophonic.getDefaults(), {\n      harmonicity: 3,\n      oscillator: Object.assign(omitFromObject(OmniOscillator.getDefaults(), [...Object.keys(Source.getDefaults()), \"frequency\", \"detune\"]), {\n        type: \"sine\"\n      }),\n      envelope: Object.assign(omitFromObject(Envelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())), {\n        attack: 0.01,\n        decay: 0.01,\n        sustain: 1,\n        release: 0.5\n      }),\n      modulation: Object.assign(omitFromObject(OmniOscillator.getDefaults(), [...Object.keys(Source.getDefaults()), \"frequency\", \"detune\"]), {\n        type: \"square\"\n      }),\n      modulationEnvelope: Object.assign(omitFromObject(Envelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())), {\n        attack: 0.5,\n        decay: 0.0,\n        sustain: 1,\n        release: 0.5\n      })\n    });\n  }\n  /**\n   * Trigger the attack portion of the note\n   */\n\n\n  _triggerEnvelopeAttack(time, velocity) {\n    // @ts-ignore\n    this._carrier._triggerEnvelopeAttack(time, velocity); // @ts-ignore\n\n\n    this._modulator._triggerEnvelopeAttack(time, velocity);\n  }\n  /**\n   * Trigger the release portion of the note\n   */\n\n\n  _triggerEnvelopeRelease(time) {\n    // @ts-ignore\n    this._carrier._triggerEnvelopeRelease(time); // @ts-ignore\n\n\n    this._modulator._triggerEnvelopeRelease(time);\n\n    return this;\n  }\n\n  getLevelAtTime(time) {\n    time = this.toSeconds(time);\n    return this.envelope.getValueAtTime(time);\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._carrier.dispose();\n\n    this._modulator.dispose();\n\n    this.frequency.dispose();\n    this.detune.dispose();\n    this.harmonicity.dispose();\n\n    this._modulationNode.dispose();\n\n    return this;\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}