{"ast":null,"code":"const _excluded = [\"coneInnerAngle\", \"coneOuterAngle\", \"coneOuterGain\", \"distanceModel\", \"maxDistance\", \"orientationX\", \"orientationY\", \"orientationZ\", \"panningModel\", \"positionX\", \"positionY\", \"positionZ\", \"refDistance\", \"rolloffFactor\"];\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { interceptConnections } from '../helpers/intercept-connections';\nexport const createNativePannerNodeFakerFactory = (connectNativeAudioNodeToNativeAudioNode, createInvalidStateError, createNativeChannelMergerNode, createNativeGainNode, createNativeScriptProcessorNode, createNativeWaveShaperNode, createNotSupportedError, disconnectNativeAudioNodeFromNativeAudioNode, getFirstSample, monitorConnections) => {\n  return (nativeContext, _ref) => {\n    let coneInnerAngle = _ref.coneInnerAngle,\n        coneOuterAngle = _ref.coneOuterAngle,\n        coneOuterGain = _ref.coneOuterGain,\n        distanceModel = _ref.distanceModel,\n        maxDistance = _ref.maxDistance,\n        orientationX = _ref.orientationX,\n        orientationY = _ref.orientationY,\n        orientationZ = _ref.orientationZ,\n        panningModel = _ref.panningModel,\n        positionX = _ref.positionX,\n        positionY = _ref.positionY,\n        positionZ = _ref.positionZ,\n        refDistance = _ref.refDistance,\n        rolloffFactor = _ref.rolloffFactor,\n        audioNodeOptions = _objectWithoutProperties(_ref, _excluded);\n\n    const pannerNode = nativeContext.createPanner(); // Bug #125: Safari does not throw an error yet.\n\n    if (audioNodeOptions.channelCount > 2) {\n      throw createNotSupportedError();\n    } // Bug #126: Safari does not throw an error yet.\n\n\n    if (audioNodeOptions.channelCountMode === 'max') {\n      throw createNotSupportedError();\n    }\n\n    assignNativeAudioNodeOptions(pannerNode, audioNodeOptions);\n    const SINGLE_CHANNEL_OPTIONS = {\n      channelCount: 1,\n      channelCountMode: 'explicit',\n      channelInterpretation: 'discrete'\n    };\n    const channelMergerNode = createNativeChannelMergerNode(nativeContext, _objectSpread(_objectSpread({}, SINGLE_CHANNEL_OPTIONS), {}, {\n      channelInterpretation: 'speakers',\n      numberOfInputs: 6\n    }));\n    const inputGainNode = createNativeGainNode(nativeContext, _objectSpread(_objectSpread({}, audioNodeOptions), {}, {\n      gain: 1\n    }));\n    const orientationXGainNode = createNativeGainNode(nativeContext, _objectSpread(_objectSpread({}, SINGLE_CHANNEL_OPTIONS), {}, {\n      gain: 1\n    }));\n    const orientationYGainNode = createNativeGainNode(nativeContext, _objectSpread(_objectSpread({}, SINGLE_CHANNEL_OPTIONS), {}, {\n      gain: 0\n    }));\n    const orientationZGainNode = createNativeGainNode(nativeContext, _objectSpread(_objectSpread({}, SINGLE_CHANNEL_OPTIONS), {}, {\n      gain: 0\n    }));\n    const positionXGainNode = createNativeGainNode(nativeContext, _objectSpread(_objectSpread({}, SINGLE_CHANNEL_OPTIONS), {}, {\n      gain: 0\n    }));\n    const positionYGainNode = createNativeGainNode(nativeContext, _objectSpread(_objectSpread({}, SINGLE_CHANNEL_OPTIONS), {}, {\n      gain: 0\n    }));\n    const positionZGainNode = createNativeGainNode(nativeContext, _objectSpread(_objectSpread({}, SINGLE_CHANNEL_OPTIONS), {}, {\n      gain: 0\n    }));\n    const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, 256, 6, 1);\n    const waveShaperNode = createNativeWaveShaperNode(nativeContext, _objectSpread(_objectSpread({}, SINGLE_CHANNEL_OPTIONS), {}, {\n      curve: new Float32Array([1, 1]),\n      oversample: 'none'\n    }));\n    let lastOrientation = [orientationX, orientationY, orientationZ];\n    let lastPosition = [positionX, positionY, positionZ];\n    const buffer = new Float32Array(1); // tslint:disable-next-line:deprecation\n\n    scriptProcessorNode.onaudioprocess = _ref2 => {\n      let inputBuffer = _ref2.inputBuffer;\n      const orientation = [getFirstSample(inputBuffer, buffer, 0), getFirstSample(inputBuffer, buffer, 1), getFirstSample(inputBuffer, buffer, 2)];\n\n      if (orientation.some((value, index) => value !== lastOrientation[index])) {\n        pannerNode.setOrientation(...orientation); // tslint:disable-line:deprecation\n\n        lastOrientation = orientation;\n      }\n\n      const positon = [getFirstSample(inputBuffer, buffer, 3), getFirstSample(inputBuffer, buffer, 4), getFirstSample(inputBuffer, buffer, 5)];\n\n      if (positon.some((value, index) => value !== lastPosition[index])) {\n        pannerNode.setPosition(...positon); // tslint:disable-line:deprecation\n\n        lastPosition = positon;\n      }\n    };\n\n    Object.defineProperty(orientationYGainNode.gain, 'defaultValue', {\n      get: () => 0\n    });\n    Object.defineProperty(orientationZGainNode.gain, 'defaultValue', {\n      get: () => 0\n    });\n    Object.defineProperty(positionXGainNode.gain, 'defaultValue', {\n      get: () => 0\n    });\n    Object.defineProperty(positionYGainNode.gain, 'defaultValue', {\n      get: () => 0\n    });\n    Object.defineProperty(positionZGainNode.gain, 'defaultValue', {\n      get: () => 0\n    });\n    const nativePannerNodeFaker = {\n      get bufferSize() {\n        return undefined;\n      },\n\n      get channelCount() {\n        return pannerNode.channelCount;\n      },\n\n      set channelCount(value) {\n        // Bug #125: Safari does not throw an error yet.\n        if (value > 2) {\n          throw createNotSupportedError();\n        }\n\n        inputGainNode.channelCount = value;\n        pannerNode.channelCount = value;\n      },\n\n      get channelCountMode() {\n        return pannerNode.channelCountMode;\n      },\n\n      set channelCountMode(value) {\n        // Bug #126: Safari does not throw an error yet.\n        if (value === 'max') {\n          throw createNotSupportedError();\n        }\n\n        inputGainNode.channelCountMode = value;\n        pannerNode.channelCountMode = value;\n      },\n\n      get channelInterpretation() {\n        return pannerNode.channelInterpretation;\n      },\n\n      set channelInterpretation(value) {\n        inputGainNode.channelInterpretation = value;\n        pannerNode.channelInterpretation = value;\n      },\n\n      get coneInnerAngle() {\n        return pannerNode.coneInnerAngle;\n      },\n\n      set coneInnerAngle(value) {\n        pannerNode.coneInnerAngle = value;\n      },\n\n      get coneOuterAngle() {\n        return pannerNode.coneOuterAngle;\n      },\n\n      set coneOuterAngle(value) {\n        pannerNode.coneOuterAngle = value;\n      },\n\n      get coneOuterGain() {\n        return pannerNode.coneOuterGain;\n      },\n\n      set coneOuterGain(value) {\n        // Bug #127: Safari does not throw an InvalidStateError yet.\n        if (value < 0 || value > 1) {\n          throw createInvalidStateError();\n        }\n\n        pannerNode.coneOuterGain = value;\n      },\n\n      get context() {\n        return pannerNode.context;\n      },\n\n      get distanceModel() {\n        return pannerNode.distanceModel;\n      },\n\n      set distanceModel(value) {\n        pannerNode.distanceModel = value;\n      },\n\n      get inputs() {\n        return [inputGainNode];\n      },\n\n      get maxDistance() {\n        return pannerNode.maxDistance;\n      },\n\n      set maxDistance(value) {\n        // Bug #128: Safari does not throw an error yet.\n        if (value < 0) {\n          throw new RangeError();\n        }\n\n        pannerNode.maxDistance = value;\n      },\n\n      get numberOfInputs() {\n        return pannerNode.numberOfInputs;\n      },\n\n      get numberOfOutputs() {\n        return pannerNode.numberOfOutputs;\n      },\n\n      get orientationX() {\n        return orientationXGainNode.gain;\n      },\n\n      get orientationY() {\n        return orientationYGainNode.gain;\n      },\n\n      get orientationZ() {\n        return orientationZGainNode.gain;\n      },\n\n      get panningModel() {\n        return pannerNode.panningModel;\n      },\n\n      set panningModel(value) {\n        pannerNode.panningModel = value;\n      },\n\n      get positionX() {\n        return positionXGainNode.gain;\n      },\n\n      get positionY() {\n        return positionYGainNode.gain;\n      },\n\n      get positionZ() {\n        return positionZGainNode.gain;\n      },\n\n      get refDistance() {\n        return pannerNode.refDistance;\n      },\n\n      set refDistance(value) {\n        // Bug #129: Safari does not throw an error yet.\n        if (value < 0) {\n          throw new RangeError();\n        }\n\n        pannerNode.refDistance = value;\n      },\n\n      get rolloffFactor() {\n        return pannerNode.rolloffFactor;\n      },\n\n      set rolloffFactor(value) {\n        // Bug #130: Safari does not throw an error yet.\n        if (value < 0) {\n          throw new RangeError();\n        }\n\n        pannerNode.rolloffFactor = value;\n      },\n\n      addEventListener() {\n        return inputGainNode.addEventListener(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);\n      },\n\n      dispatchEvent() {\n        return inputGainNode.dispatchEvent(arguments.length <= 0 ? undefined : arguments[0]);\n      },\n\n      removeEventListener() {\n        return inputGainNode.removeEventListener(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);\n      }\n\n    };\n\n    if (coneInnerAngle !== nativePannerNodeFaker.coneInnerAngle) {\n      nativePannerNodeFaker.coneInnerAngle = coneInnerAngle;\n    }\n\n    if (coneOuterAngle !== nativePannerNodeFaker.coneOuterAngle) {\n      nativePannerNodeFaker.coneOuterAngle = coneOuterAngle;\n    }\n\n    if (coneOuterGain !== nativePannerNodeFaker.coneOuterGain) {\n      nativePannerNodeFaker.coneOuterGain = coneOuterGain;\n    }\n\n    if (distanceModel !== nativePannerNodeFaker.distanceModel) {\n      nativePannerNodeFaker.distanceModel = distanceModel;\n    }\n\n    if (maxDistance !== nativePannerNodeFaker.maxDistance) {\n      nativePannerNodeFaker.maxDistance = maxDistance;\n    }\n\n    if (orientationX !== nativePannerNodeFaker.orientationX.value) {\n      nativePannerNodeFaker.orientationX.value = orientationX;\n    }\n\n    if (orientationY !== nativePannerNodeFaker.orientationY.value) {\n      nativePannerNodeFaker.orientationY.value = orientationY;\n    }\n\n    if (orientationZ !== nativePannerNodeFaker.orientationZ.value) {\n      nativePannerNodeFaker.orientationZ.value = orientationZ;\n    }\n\n    if (panningModel !== nativePannerNodeFaker.panningModel) {\n      nativePannerNodeFaker.panningModel = panningModel;\n    }\n\n    if (positionX !== nativePannerNodeFaker.positionX.value) {\n      nativePannerNodeFaker.positionX.value = positionX;\n    }\n\n    if (positionY !== nativePannerNodeFaker.positionY.value) {\n      nativePannerNodeFaker.positionY.value = positionY;\n    }\n\n    if (positionZ !== nativePannerNodeFaker.positionZ.value) {\n      nativePannerNodeFaker.positionZ.value = positionZ;\n    }\n\n    if (refDistance !== nativePannerNodeFaker.refDistance) {\n      nativePannerNodeFaker.refDistance = refDistance;\n    }\n\n    if (rolloffFactor !== nativePannerNodeFaker.rolloffFactor) {\n      nativePannerNodeFaker.rolloffFactor = rolloffFactor;\n    }\n\n    if (lastOrientation[0] !== 1 || lastOrientation[1] !== 0 || lastOrientation[2] !== 0) {\n      pannerNode.setOrientation(...lastOrientation); // tslint:disable-line:deprecation\n    }\n\n    if (lastPosition[0] !== 0 || lastPosition[1] !== 0 || lastPosition[2] !== 0) {\n      pannerNode.setPosition(...lastPosition); // tslint:disable-line:deprecation\n    }\n\n    const whenConnected = () => {\n      inputGainNode.connect(pannerNode); // Bug #119: Safari does not fully support the WaveShaperNode.\n\n      connectNativeAudioNodeToNativeAudioNode(inputGainNode, waveShaperNode, 0, 0);\n      waveShaperNode.connect(orientationXGainNode).connect(channelMergerNode, 0, 0);\n      waveShaperNode.connect(orientationYGainNode).connect(channelMergerNode, 0, 1);\n      waveShaperNode.connect(orientationZGainNode).connect(channelMergerNode, 0, 2);\n      waveShaperNode.connect(positionXGainNode).connect(channelMergerNode, 0, 3);\n      waveShaperNode.connect(positionYGainNode).connect(channelMergerNode, 0, 4);\n      waveShaperNode.connect(positionZGainNode).connect(channelMergerNode, 0, 5);\n      channelMergerNode.connect(scriptProcessorNode).connect(nativeContext.destination);\n    };\n\n    const whenDisconnected = () => {\n      inputGainNode.disconnect(pannerNode); // Bug #119: Safari does not fully support the WaveShaperNode.\n\n      disconnectNativeAudioNodeFromNativeAudioNode(inputGainNode, waveShaperNode, 0, 0);\n      waveShaperNode.disconnect(orientationXGainNode);\n      orientationXGainNode.disconnect(channelMergerNode);\n      waveShaperNode.disconnect(orientationYGainNode);\n      orientationYGainNode.disconnect(channelMergerNode);\n      waveShaperNode.disconnect(orientationZGainNode);\n      orientationZGainNode.disconnect(channelMergerNode);\n      waveShaperNode.disconnect(positionXGainNode);\n      positionXGainNode.disconnect(channelMergerNode);\n      waveShaperNode.disconnect(positionYGainNode);\n      positionYGainNode.disconnect(channelMergerNode);\n      waveShaperNode.disconnect(positionZGainNode);\n      positionZGainNode.disconnect(channelMergerNode);\n      channelMergerNode.disconnect(scriptProcessorNode);\n      scriptProcessorNode.disconnect(nativeContext.destination);\n    };\n\n    return monitorConnections(interceptConnections(nativePannerNodeFaker, pannerNode), whenConnected, whenDisconnected);\n  };\n};","map":null,"metadata":{},"sourceType":"module"}