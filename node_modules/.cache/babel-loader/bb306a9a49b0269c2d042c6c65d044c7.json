{"ast":null,"code":"import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nexport const createAudioListenerFactory = (createAudioParam, createNativeChannelMergerNode, createNativeConstantSourceNode, createNativeScriptProcessorNode, createNotSupportedError, getFirstSample, isNativeOfflineAudioContext, overwriteAccessors) => {\n  return (context, nativeContext) => {\n    const nativeListener = nativeContext.listener; // Bug #117: Only Chrome & Edge support the new interface already.\n\n    const createFakeAudioParams = () => {\n      const buffer = new Float32Array(1);\n      const channelMergerNode = createNativeChannelMergerNode(nativeContext, {\n        channelCount: 1,\n        channelCountMode: 'explicit',\n        channelInterpretation: 'speakers',\n        numberOfInputs: 9\n      });\n      const isOffline = isNativeOfflineAudioContext(nativeContext);\n      let isScriptProcessorNodeCreated = false;\n      let lastOrientation = [0, 0, -1, 0, 1, 0];\n      let lastPosition = [0, 0, 0];\n\n      const createScriptProcessorNode = () => {\n        if (isScriptProcessorNodeCreated) {\n          return;\n        }\n\n        isScriptProcessorNodeCreated = true;\n        const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, 256, 9, 0); // tslint:disable-next-line:deprecation\n\n        scriptProcessorNode.onaudioprocess = _ref => {\n          let inputBuffer = _ref.inputBuffer;\n          const orientation = [getFirstSample(inputBuffer, buffer, 0), getFirstSample(inputBuffer, buffer, 1), getFirstSample(inputBuffer, buffer, 2), getFirstSample(inputBuffer, buffer, 3), getFirstSample(inputBuffer, buffer, 4), getFirstSample(inputBuffer, buffer, 5)];\n\n          if (orientation.some((value, index) => value !== lastOrientation[index])) {\n            nativeListener.setOrientation(...orientation); // tslint:disable-line:deprecation\n\n            lastOrientation = orientation;\n          }\n\n          const positon = [getFirstSample(inputBuffer, buffer, 6), getFirstSample(inputBuffer, buffer, 7), getFirstSample(inputBuffer, buffer, 8)];\n\n          if (positon.some((value, index) => value !== lastPosition[index])) {\n            nativeListener.setPosition(...positon); // tslint:disable-line:deprecation\n\n            lastPosition = positon;\n          }\n        };\n\n        channelMergerNode.connect(scriptProcessorNode);\n      };\n\n      const createSetOrientation = index => value => {\n        if (value !== lastOrientation[index]) {\n          lastOrientation[index] = value;\n          nativeListener.setOrientation(...lastOrientation); // tslint:disable-line:deprecation\n        }\n      };\n\n      const createSetPosition = index => value => {\n        if (value !== lastPosition[index]) {\n          lastPosition[index] = value;\n          nativeListener.setPosition(...lastPosition); // tslint:disable-line:deprecation\n        }\n      };\n\n      const createFakeAudioParam = (input, initialValue, setValue) => {\n        const constantSourceNode = createNativeConstantSourceNode(nativeContext, {\n          channelCount: 1,\n          channelCountMode: 'explicit',\n          channelInterpretation: 'discrete',\n          offset: initialValue\n        });\n        constantSourceNode.connect(channelMergerNode, 0, input); // @todo This should be stopped when the context is closed.\n\n        constantSourceNode.start();\n        Object.defineProperty(constantSourceNode.offset, 'defaultValue', {\n          get() {\n            return initialValue;\n          }\n\n        });\n        /*\n         * Bug #62 & #74: Safari does not support ConstantSourceNodes and does not export the correct values for maxValue and\n         * minValue for GainNodes.\n         */\n\n        const audioParam = createAudioParam({\n          context\n        }, isOffline, constantSourceNode.offset, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n        overwriteAccessors(audioParam, 'value', get => () => get.call(audioParam), set => value => {\n          try {\n            set.call(audioParam, value);\n          } catch (err) {\n            if (err.code !== 9) {\n              throw err;\n            }\n          }\n\n          createScriptProcessorNode();\n\n          if (isOffline) {\n            // Bug #117: Using setOrientation() and setPosition() doesn't work with an OfflineAudioContext.\n            setValue(value);\n          }\n        });\n\n        audioParam.cancelAndHoldAtTime = (cancelAndHoldAtTime => {\n          if (isOffline) {\n            return () => {\n              throw createNotSupportedError();\n            };\n          }\n\n          return function () {\n            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n              args[_key] = arguments[_key];\n            }\n\n            const value = cancelAndHoldAtTime.apply(audioParam, args);\n            createScriptProcessorNode();\n            return value;\n          };\n        })(audioParam.cancelAndHoldAtTime);\n\n        audioParam.cancelScheduledValues = (cancelScheduledValues => {\n          if (isOffline) {\n            return () => {\n              throw createNotSupportedError();\n            };\n          }\n\n          return function () {\n            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n              args[_key2] = arguments[_key2];\n            }\n\n            const value = cancelScheduledValues.apply(audioParam, args);\n            createScriptProcessorNode();\n            return value;\n          };\n        })(audioParam.cancelScheduledValues);\n\n        audioParam.exponentialRampToValueAtTime = (exponentialRampToValueAtTime => {\n          if (isOffline) {\n            return () => {\n              throw createNotSupportedError();\n            };\n          }\n\n          return function () {\n            for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n              args[_key3] = arguments[_key3];\n            }\n\n            const value = exponentialRampToValueAtTime.apply(audioParam, args);\n            createScriptProcessorNode();\n            return value;\n          };\n        })(audioParam.exponentialRampToValueAtTime);\n\n        audioParam.linearRampToValueAtTime = (linearRampToValueAtTime => {\n          if (isOffline) {\n            return () => {\n              throw createNotSupportedError();\n            };\n          }\n\n          return function () {\n            for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n              args[_key4] = arguments[_key4];\n            }\n\n            const value = linearRampToValueAtTime.apply(audioParam, args);\n            createScriptProcessorNode();\n            return value;\n          };\n        })(audioParam.linearRampToValueAtTime);\n\n        audioParam.setTargetAtTime = (setTargetAtTime => {\n          if (isOffline) {\n            return () => {\n              throw createNotSupportedError();\n            };\n          }\n\n          return function () {\n            for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n              args[_key5] = arguments[_key5];\n            }\n\n            const value = setTargetAtTime.apply(audioParam, args);\n            createScriptProcessorNode();\n            return value;\n          };\n        })(audioParam.setTargetAtTime);\n\n        audioParam.setValueAtTime = (setValueAtTime => {\n          if (isOffline) {\n            return () => {\n              throw createNotSupportedError();\n            };\n          }\n\n          return function () {\n            for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n              args[_key6] = arguments[_key6];\n            }\n\n            const value = setValueAtTime.apply(audioParam, args);\n            createScriptProcessorNode();\n            return value;\n          };\n        })(audioParam.setValueAtTime);\n\n        audioParam.setValueCurveAtTime = (setValueCurveAtTime => {\n          if (isOffline) {\n            return () => {\n              throw createNotSupportedError();\n            };\n          }\n\n          return function () {\n            for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n              args[_key7] = arguments[_key7];\n            }\n\n            const value = setValueCurveAtTime.apply(audioParam, args);\n            createScriptProcessorNode();\n            return value;\n          };\n        })(audioParam.setValueCurveAtTime);\n\n        return audioParam;\n      };\n\n      return {\n        forwardX: createFakeAudioParam(0, 0, createSetOrientation(0)),\n        forwardY: createFakeAudioParam(1, 0, createSetOrientation(1)),\n        forwardZ: createFakeAudioParam(2, -1, createSetOrientation(2)),\n        positionX: createFakeAudioParam(6, 0, createSetPosition(0)),\n        positionY: createFakeAudioParam(7, 0, createSetPosition(1)),\n        positionZ: createFakeAudioParam(8, 0, createSetPosition(2)),\n        upX: createFakeAudioParam(3, 0, createSetOrientation(3)),\n        upY: createFakeAudioParam(4, 1, createSetOrientation(4)),\n        upZ: createFakeAudioParam(5, 0, createSetOrientation(5))\n      };\n    };\n\n    const _ref2 = nativeListener.forwardX === undefined ? createFakeAudioParams() : nativeListener,\n          forwardX = _ref2.forwardX,\n          forwardY = _ref2.forwardY,\n          forwardZ = _ref2.forwardZ,\n          positionX = _ref2.positionX,\n          positionY = _ref2.positionY,\n          positionZ = _ref2.positionZ,\n          upX = _ref2.upX,\n          upY = _ref2.upY,\n          upZ = _ref2.upZ;\n\n    return {\n      get forwardX() {\n        return forwardX;\n      },\n\n      get forwardY() {\n        return forwardY;\n      },\n\n      get forwardZ() {\n        return forwardZ;\n      },\n\n      get positionX() {\n        return positionX;\n      },\n\n      get positionY() {\n        return positionY;\n      },\n\n      get positionZ() {\n        return positionZ;\n      },\n\n      get upX() {\n        return upX;\n      },\n\n      get upY() {\n        return upY;\n      },\n\n      get upZ() {\n        return upZ;\n      }\n\n    };\n  };\n};","map":null,"metadata":{},"sourceType":"module"}