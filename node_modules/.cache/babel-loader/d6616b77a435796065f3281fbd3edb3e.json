{"ast":null,"code":"import { FeedbackEffect } from \"./FeedbackEffect\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { LFO } from \"../source/oscillator/LFO\";\nimport { Delay } from \"../core/context/Delay\";\nimport { CrossFade } from \"../component/channel/CrossFade\";\nimport { Signal } from \"../signal/Signal\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { intervalToFrequencyRatio } from \"../core/type/Conversions\";\n/**\n * PitchShift does near-realtime pitch shifting to the incoming signal.\n * The effect is achieved by speeding up or slowing down the delayTime\n * of a DelayNode using a sawtooth wave.\n * Algorithm found in [this pdf](http://dsp-book.narod.ru/soundproc.pdf).\n * Additional reference by [Miller Pucket](http://msp.ucsd.edu/techniques/v0.11/book-html/node115.html).\n * @category Effect\n */\n\nexport class PitchShift extends FeedbackEffect {\n  constructor() {\n    super(optionsFromArguments(PitchShift.getDefaults(), arguments, [\"pitch\"]));\n    this.name = \"PitchShift\";\n    const options = optionsFromArguments(PitchShift.getDefaults(), arguments, [\"pitch\"]);\n    this._frequency = new Signal({\n      context: this.context\n    });\n    this._delayA = new Delay({\n      maxDelay: 1,\n      context: this.context\n    });\n    this._lfoA = new LFO({\n      context: this.context,\n      min: 0,\n      max: 0.1,\n      type: \"sawtooth\"\n    }).connect(this._delayA.delayTime);\n    this._delayB = new Delay({\n      maxDelay: 1,\n      context: this.context\n    });\n    this._lfoB = new LFO({\n      context: this.context,\n      min: 0,\n      max: 0.1,\n      type: \"sawtooth\",\n      phase: 180\n    }).connect(this._delayB.delayTime);\n    this._crossFade = new CrossFade({\n      context: this.context\n    });\n    this._crossFadeLFO = new LFO({\n      context: this.context,\n      min: 0,\n      max: 1,\n      type: \"triangle\",\n      phase: 90\n    }).connect(this._crossFade.fade);\n    this._feedbackDelay = new Delay({\n      delayTime: options.delayTime,\n      context: this.context\n    });\n    this.delayTime = this._feedbackDelay.delayTime;\n    readOnly(this, \"delayTime\");\n    this._pitch = options.pitch;\n    this._windowSize = options.windowSize; // connect the two delay lines up\n\n    this._delayA.connect(this._crossFade.a);\n\n    this._delayB.connect(this._crossFade.b); // connect the frequency\n\n\n    this._frequency.fan(this._lfoA.frequency, this._lfoB.frequency, this._crossFadeLFO.frequency); // route the input\n\n\n    this.effectSend.fan(this._delayA, this._delayB);\n\n    this._crossFade.chain(this._feedbackDelay, this.effectReturn); // start the LFOs at the same time\n\n\n    const now = this.now();\n\n    this._lfoA.start(now);\n\n    this._lfoB.start(now);\n\n    this._crossFadeLFO.start(now); // set the initial value\n\n\n    this.windowSize = this._windowSize;\n  }\n\n  static getDefaults() {\n    return Object.assign(FeedbackEffect.getDefaults(), {\n      pitch: 0,\n      windowSize: 0.1,\n      delayTime: 0,\n      feedback: 0\n    });\n  }\n  /**\n   * Repitch the incoming signal by some interval (measured in semi-tones).\n   * @example\n   * const pitchShift = new Tone.PitchShift().toDestination();\n   * const osc = new Tone.Oscillator().connect(pitchShift).start().toDestination();\n   * pitchShift.pitch = -12; // down one octave\n   * pitchShift.pitch = 7; // up a fifth\n   */\n\n\n  get pitch() {\n    return this._pitch;\n  }\n\n  set pitch(interval) {\n    this._pitch = interval;\n    let factor = 0;\n\n    if (interval < 0) {\n      this._lfoA.min = 0;\n      this._lfoA.max = this._windowSize;\n      this._lfoB.min = 0;\n      this._lfoB.max = this._windowSize;\n      factor = intervalToFrequencyRatio(interval - 1) + 1;\n    } else {\n      this._lfoA.min = this._windowSize;\n      this._lfoA.max = 0;\n      this._lfoB.min = this._windowSize;\n      this._lfoB.max = 0;\n      factor = intervalToFrequencyRatio(interval) - 1;\n    }\n\n    this._frequency.value = factor * (1.2 / this._windowSize);\n  }\n  /**\n   * The window size corresponds roughly to the sample length in a looping sampler.\n   * Smaller values are desirable for a less noticeable delay time of the pitch shifted\n   * signal, but larger values will result in smoother pitch shifting for larger intervals.\n   * A nominal range of 0.03 to 0.1 is recommended.\n   */\n\n\n  get windowSize() {\n    return this._windowSize;\n  }\n\n  set windowSize(size) {\n    this._windowSize = this.toSeconds(size);\n    this.pitch = this._pitch;\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._frequency.dispose();\n\n    this._delayA.dispose();\n\n    this._delayB.dispose();\n\n    this._lfoA.dispose();\n\n    this._lfoB.dispose();\n\n    this._crossFade.dispose();\n\n    this._crossFadeLFO.dispose();\n\n    this._feedbackDelay.dispose();\n\n    return this;\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}