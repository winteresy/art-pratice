{"ast":null,"code":"import { Gain } from \"../../core/context/Gain\";\nimport { Param } from \"../../core/context/Param\";\nimport { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { AudioToGain } from \"../../signal/AudioToGain\";\nimport { Scale } from \"../../signal/Scale\";\nimport { connectSignal, Signal } from \"../../signal/Signal\";\nimport { Zero } from \"../../signal/Zero\";\nimport { Oscillator } from \"./Oscillator\";\n/**\n * LFO stands for low frequency oscillator. LFO produces an output signal\n * which can be attached to an AudioParam or Tone.Signal\n * in order to modulate that parameter with an oscillator. The LFO can\n * also be synced to the transport to start/stop and change when the tempo changes.\n * @example\n * return Tone.Offline(() => {\n * \tconst lfo = new Tone.LFO(\"4n\", 400, 4000).start().toDestination();\n * }, 0.5, 1);\n * @category Source\n */\n\nexport class LFO extends ToneAudioNode {\n  constructor() {\n    super(optionsFromArguments(LFO.getDefaults(), arguments, [\"frequency\", \"min\", \"max\"]));\n    this.name = \"LFO\";\n    /**\n     * The value that the LFO outputs when it's stopped\n     */\n\n    this._stoppedValue = 0;\n    /**\n     * A private placeholder for the units\n     */\n\n    this._units = \"number\";\n    /**\n     * If the input value is converted using the [[units]]\n     */\n\n    this.convert = true;\n    /**\n     * Private methods borrowed from Param\n     */\n    // @ts-ignore\n\n    this._fromType = Param.prototype._fromType; // @ts-ignore\n\n    this._toType = Param.prototype._toType; // @ts-ignore\n\n    this._is = Param.prototype._is; // @ts-ignore\n\n    this._clampValue = Param.prototype._clampValue;\n    const options = optionsFromArguments(LFO.getDefaults(), arguments, [\"frequency\", \"min\", \"max\"]);\n    this._oscillator = new Oscillator(options);\n    this.frequency = this._oscillator.frequency;\n    this._amplitudeGain = new Gain({\n      context: this.context,\n      gain: options.amplitude,\n      units: \"normalRange\"\n    });\n    this.amplitude = this._amplitudeGain.gain;\n    this._stoppedSignal = new Signal({\n      context: this.context,\n      units: \"audioRange\",\n      value: 0\n    });\n    this._zeros = new Zero({\n      context: this.context\n    });\n    this._a2g = new AudioToGain({\n      context: this.context\n    });\n    this._scaler = this.output = new Scale({\n      context: this.context,\n      max: options.max,\n      min: options.min\n    });\n    this.units = options.units;\n    this.min = options.min;\n    this.max = options.max; // connect it up\n\n    this._oscillator.chain(this._amplitudeGain, this._a2g, this._scaler);\n\n    this._zeros.connect(this._a2g);\n\n    this._stoppedSignal.connect(this._a2g);\n\n    readOnly(this, [\"amplitude\", \"frequency\"]);\n    this.phase = options.phase;\n  }\n\n  static getDefaults() {\n    return Object.assign(Oscillator.getDefaults(), {\n      amplitude: 1,\n      frequency: \"4n\",\n      max: 1,\n      min: 0,\n      type: \"sine\",\n      units: \"number\"\n    });\n  }\n  /**\n   * Start the LFO.\n   * @param time The time the LFO will start\n   */\n\n\n  start(time) {\n    time = this.toSeconds(time);\n\n    this._stoppedSignal.setValueAtTime(0, time);\n\n    this._oscillator.start(time);\n\n    return this;\n  }\n  /**\n   * Stop the LFO.\n   * @param  time The time the LFO will stop\n   */\n\n\n  stop(time) {\n    time = this.toSeconds(time);\n\n    this._stoppedSignal.setValueAtTime(this._stoppedValue, time);\n\n    this._oscillator.stop(time);\n\n    return this;\n  }\n  /**\n   * Sync the start/stop/pause to the transport\n   * and the frequency to the bpm of the transport\n   * @example\n   * const lfo = new Tone.LFO(\"8n\");\n   * lfo.sync().start(0);\n   * // the rate of the LFO will always be an eighth note, even as the tempo changes\n   */\n\n\n  sync() {\n    this._oscillator.sync();\n\n    this._oscillator.syncFrequency();\n\n    return this;\n  }\n  /**\n   * unsync the LFO from transport control\n   */\n\n\n  unsync() {\n    this._oscillator.unsync();\n\n    this._oscillator.unsyncFrequency();\n\n    return this;\n  }\n  /**\n   * After the oscillator waveform is updated, reset the `_stoppedSignal` value to match the updated waveform\n   */\n\n\n  _setStoppedValue() {\n    this._stoppedValue = this._oscillator.getInitialValue();\n    this._stoppedSignal.value = this._stoppedValue;\n  }\n  /**\n   * The minimum output of the LFO.\n   */\n\n\n  get min() {\n    return this._toType(this._scaler.min);\n  }\n\n  set min(min) {\n    min = this._fromType(min);\n    this._scaler.min = min;\n  }\n  /**\n   * The maximum output of the LFO.\n   */\n\n\n  get max() {\n    return this._toType(this._scaler.max);\n  }\n\n  set max(max) {\n    max = this._fromType(max);\n    this._scaler.max = max;\n  }\n  /**\n   * The type of the oscillator: See [[Oscillator.type]]\n   */\n\n\n  get type() {\n    return this._oscillator.type;\n  }\n\n  set type(type) {\n    this._oscillator.type = type;\n\n    this._setStoppedValue();\n  }\n  /**\n   * The oscillator's partials array: See [[Oscillator.partials]]\n   */\n\n\n  get partials() {\n    return this._oscillator.partials;\n  }\n\n  set partials(partials) {\n    this._oscillator.partials = partials;\n\n    this._setStoppedValue();\n  }\n  /**\n   * The phase of the LFO.\n   */\n\n\n  get phase() {\n    return this._oscillator.phase;\n  }\n\n  set phase(phase) {\n    this._oscillator.phase = phase;\n\n    this._setStoppedValue();\n  }\n  /**\n   * The output units of the LFO.\n   */\n\n\n  get units() {\n    return this._units;\n  }\n\n  set units(val) {\n    const currentMin = this.min;\n    const currentMax = this.max; // convert the min and the max\n\n    this._units = val;\n    this.min = currentMin;\n    this.max = currentMax;\n  }\n  /**\n   * Returns the playback state of the source, either \"started\" or \"stopped\".\n   */\n\n\n  get state() {\n    return this._oscillator.state;\n  }\n  /**\n   * @param node the destination to connect to\n   * @param outputNum the optional output number\n   * @param inputNum the input number\n   */\n\n\n  connect(node, outputNum, inputNum) {\n    if (node instanceof Param || node instanceof Signal) {\n      this.convert = node.convert;\n      this.units = node.units;\n    }\n\n    connectSignal(this, node, outputNum, inputNum);\n    return this;\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._oscillator.dispose();\n\n    this._stoppedSignal.dispose();\n\n    this._zeros.dispose();\n\n    this._scaler.dispose();\n\n    this._a2g.dispose();\n\n    this._amplitudeGain.dispose();\n\n    this.amplitude.dispose();\n    return this;\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}